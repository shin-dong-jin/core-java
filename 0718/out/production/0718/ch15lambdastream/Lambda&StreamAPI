Lambda & Stream API

1. Lambda Expression
    1) 원래 객체지향언어에서 사용하지 않고, Scala나 Groovy같은 함수형 언어에서 사용하던 문법

    2) 메소드는 클래스 안에서 객체의 행위를 정의하지만,
        Expression이라고 쓴 이유는 Method의 역할과 동일하지만 특정 클래스 소속이 아니기 때문이다.

    3) Lambda Expression을 사용하면서 매개변수와 리턴 타입만으로 간단히 코드를 작성할 수 있기 때문에,
        병렬 프로그래밍을 하지 않아도 되어 Collections Framework에서 효과적인 코드를 작성할 수 있다.

    4) 순서
        - 객체의 생성 부분을 삭제한다.
        - @Override 삭제한다.
        - 접근제한자, 리턴타입, 메소드 이름을 삭제한다.
        - 파라미터 타입을 삭제한다.
            굳이 파라미터 타입을 정의하지 않아도 추론이 가능하다면 파라미터 타입 삭제 가능하고,
            추론이 불가능하면 파라미터 타입을 명시하는데, 모두 명시해야한다.
        - 메소드 바디의 return을 삭제한다.
        - 메소드 () 뒤의 {}를 삭제한다.
            메소드 구현부의 문장이 한 개일 경우에만
        - 메소드 파라미터 선언부 ()와 {} 사이였던 부분을 -> 연산자로 연결한다.

    5) @FunctionalInterface
        - 일반적으로 Interface는 한 개 이상의 추상메소드를 가질 수 있다.
        - 하지만, 여러개의 추상메소드가 있으면 Lambda Expression에 에러가 발생한다.
        - 그래서, Lambda Expression에서 사용하기 위한 인터페이스를 지정하기 위한 어노테이션이다.

    6) Method reference
        - ClassName::methodName
        - Lambda Expression의 구현코드에서 다른 클래스의 단 하나의 메소드만 참조한다는 것을 보장할 때 사용


2. Stream API
    1) Stream?
        배열이나 Collection과 같이 여러 개의 데이터를 일관되게 처리하기 위해서 추가된 문법

    2) 데이터를 Stream으로 처리하기 위해서는 먼저 Stream 객체를 생성해야 한다.

    3) Stream API의 3가지 종류
        - Stream 생성
        - 생성된 Stream을 가공하는 중간연산
        - 최종적으로 결과를 만드는 최종연산

    4) 중간연산 / 최종연산
        연산의 결과가 Stream으로 리턴되면 중간연산이라고 한다.
        반면, 연산의 결과가 Stream이 아닌 형태로 나타나면 최종연산이라고 한다.

    5) 중간연산 결과가 Stream으로 리턴되기 때문에,
        Stream 연산을 계속 이어서 chain 형태로 이용할 수 있다.

    6) But, 최종연산의 결과는 Stream을 리턴하지 않기 때문에,
        일단 최종연산을 수행하면 다시 다른 Stream 연산을 수행할 수 없다. "Consuming"

    7) Stream 연산은 원본의 데이터를 읽어서 기능을 수행하지만, 그 내용을 변경하지는 않는다.